So interaction design. Um, and I use the definition from, uh, Winograd.  Uh, back ages ago, before most of you were born, I guess the design of spaces for human communication and interaction.  Uh, and that's, that's what we're trying to do.  How how can we get the right interaction space for humans?  The right communication space for humans? How how do we design that?  Um, so that we have, uh, what is best for humans.  And as you see, what we talk about a lot is best for humans.  Often conflicts with cost to develop a time.  Uh, the efficiency of the algorithm that we're using, all these sorts of things that as developers, uh,  we may try and maximise or a company might try and maximise doesn't always give  us the best result for the humans who are going to use the software afterwards.  So designing spaces for human communication interaction.  Um, how is it different from what you do as software engineers for for the software engineers in the room?  What? What's the role of software engineering? What do you do as software engineers?  Uh, you you implement the design? Yeah.  So you're interested in a software architecture or a way of of getting a design or making a design real.  Yeah, yeah. And maintainable and just all these characteristics that we have of software.  Yeah. And why is that different from interaction design?  With your focus as a software engineer. Software engineering feels very like its functionality.  Just like Mike said. Feature completed.  Check that. All of us. Maybe more.  What's the least? Waiting for somebody to be able to.  Yeah. Yeah. So I think that's my impression as well.  Often thinking around requirements stories or whatever process we use, but thinking about the functions that we want in the software.  And they're not always associated, not always driven by the user.  Although I guess some of the lean XP and others would say that that's because you're doing the process wrong.  And and the story should always reflect what a user requirement is.  How about the computer scientists in the room? Why is it is that different from what you're taught as a computer scientist?  It's just above my head for computer science tomorrow morning to study the concepts behind how we created things.  So, for example, for a software engineer, their job is to build solutions for design files.  Computer science studies the principles behind the solution building theories.  Yeah. Okay. Yeah. So the algorithms or the science behind what is going to be there.  And. And you'll see. And this is right.  I'm sure you asked when you before you started your degrees or or your parents or someone did.  What's the difference between computer science and and software engineering?  Get us. There are open days all the time. Why would my my child do software engineering rather than computer science?  Why would they do computer science rather than software engineering? And I think you've illustrated kind of the the different folk AI that we have.  And so interaction design also has a different folklore. And so it draws upon software engineering, computer science.  And often as part of what you do as software engineers or computer scientists.  But the focuses is quite different. And so we're thinking about quite different things.  And often we're thinking about and whole ecology of devices.  We're thinking about how do they interact with each other or how do we access all of those devices,  and where do they work in relationship to each other?  And as we think of different devices, well, I think they have different form factors to display in your car.  This is your mobile versus your laptop versus a screen.  You know, the interactions that we're going to have change the conventions.  We expect change across those.  I said we're taking into account a wide, wide range of factors when we're thinking about the interactions that that we're going to have with a system.  And as you remember from undergrad HCI, um,  there's a whole range of things that that whole range of aspects that we look at when we think about usability and think about interaction,  the usability ones. How effective is it to use? How efficient is it use safety aspects of it?  How useful is is the system that we're developing, how learnable?  How memorable can you remember all of those things that that we've covered in  undergrad HCI about what we want to imbue our systems with and how we think about it?  You also have seen the user experience approach.  And so looking at all those different aspects of user experience and how do we how do we ensure that we get the user  experience right in the software that that we're developing and the different approaches that we have for for doing that.  And then also those design principles that that we've looked at over previous courses.  So again, how how do we ensure the design meets these sets of requirements.  And you remember Nielsen's heuristics and the ten heuristics that we've assessed software against.  Um, and again using these heuristics to understand whether the design is meeting those sorts of requirements,  meeting the the set of users that we want to be able to use that.  Okay.  So interaction design, um, takes all of that as read and, and then we're thinking about well, and what are the interactions that, that we can have.  And I'll follow through. Um, this, uh, this, this categorisation, uh, that has come from uh, the,  the document which is referenced here and just thinking about different aspects of the  interaction and some principles that we might think about with the interaction that we have.  So it would say, well, aesthetics, aesthetics, uh, are really good.  And they will entice people. They will humour people, they will, uh, make people feel good about the software that they're using.  But aesthetic designers is very different from what software engineers and computer scientists typically do.  This design we teach design at the university, the design discipline, uh,  which teaches people how to put that sort of aesthetic over a system that that is going to be designed.  And so those people are really good at that. And you remember, HCI draws upon many, many disciplines to, to determine, um, how we create systems.  And so the aesthetics we would leave to designers, in most cases, they're the people who know how to do that.  But as we'll see with many of these things, but those designers will come with what they believe is a good system.  And and it's our role to say, well, you know, how does that work for the interactions that we want?  How usable is that going to be? How useful is that going to be?  How memorable is that going to be. And so we even if we have a a very aesthetic design that's provided to us,  we still need to test that, make sure that it works for the system that that we want.  Uh, we should think about anticipation. And this is something that that many systems are really poor.  It okay. So making sure that we're providing all of the information that people need when we go through a process.  Uh, that, that they're going to have to follow through.  I have, um, a little screen there. You can read it very well.  Um, this is the the screen that the university or the process the university has to apply for travel.  Um, so if I want to go overseas, I have to apply to travel overseas and ask for lots of information about me.  Um, and provide some of the. And just some of it.  No. So I am probably more. That's my email address.  Um. I have to select which department I'm from.  Yeah. It knows which department I'm from, the university knows which department I'm from, and has a database with me in.  It knows who my line manager is, has all this information about me.  Okay, so it's not anticipating information that that it's being asked for.  It could be providing that it's making me do more work than I need to to complete this form.  A little further on, it asks me who my line manager is.  Okay, again, the university knows it's of the database.  It asks me for that information based on UPI, so I don't have a selection list that or can't type out.  Giovanni Rossello um, I have to remember the UPI of my line manager to put it in there.  So again, anticipating information that that's needed,  forcing me to do me as a user to do more work than I need to do and to be able to complete this interaction.  And as we'll talk about many times as because doing those lookups, you know,  it's going to take a few hours of a programmers time to call the database,  get the and pass the right information through about the person, get the information back from the database, populate the fields.  Yeah. So what's the trade off? How many  people at the university?   employees at the university who have to use us, um, versus a couple of hours of programmer time to to do that?  And where's the value and what's happening there? When we think about interaction, we're going to think about autonomy.  So we don't.  We try not to force a user down just one path, and we try and give them flows to reach an end goal so that they don't feel like they have no,  no autonomy in the, in the software that they have. So, um, where we can the user make choices?  Can they do things in, in a different order from the order that you imagine they are going to do it in?  Um, and, and so how how do they achieve, um, what, what they're going to want to be able to do.  So sometimes you don't want to give them full autonomy. Okay.  So you have to know what's going to come to your system and what steps in the process, what information is going to come through.  So you guide them along a particular path. You try and give them some information, um, and, and make them go in a particular, uh, direction for it.  Part of the autonomy is just keeping people informed about what the system is doing and what the status of the system is.  Um, so here's a, uh, a piece of software called Easy Chair.  It's an open, open platform for managing conferences.  Um, and, uh, it's a nice platform that does most of the things that you need to run a conference.  Um, and this is the review for, uh, that we have inside the software and the reviews time out.  And so you have to complete your review within a certain period of time.  Otherwise, it times out, you lose all your work. That's a good design decision.  Um, but we use systems that tell us when and how much time I have left to do my review.  You know, nice status information. So as a user, I have no way of keeping myself informed about, uh, what the system is.  I can't make the right decisions about what's there.  Um, you know, I could set a timer as soon as I started the entering the screen.  Uh, but that's ridiculous. Why? Why would I, as a user, have to have to do that?  So, um, we should keep people aware and informed by the the approach they have here.  They say you may lose your work if at times out, perhaps use another application to write, review and copy and paste the review into into the system.  Yeah. Again, you know, this is it's not thinking about the user not designing for the user and not  providing the user with the autonomy that they need to complete their work.  Um, people worry about colour. Um, and, and I guess we kind of hammered that a bit in, in the HCI course.  You know that % of males are colour-blind. Uh, about % of females are colour-blind.  So about % of the population is colour-blind.  You really have to worry about, um, you know, your design or you should take into consideration in your design,  uh, what ability people have to perceive colour when you're using colour.  And that's not saying you shouldn't use colour.  That's not the corollary of a colour is very useful for giving side channels of information about what,  uh, what, uh, statuses and say we should use colour.  We should use colour cues to, to help people understand what's in the system and, and the progress that we're making in a system.  But we should test, you know, and there are plenty of tools out there that, um,  will render a page, render a scene, uh, for a particular type of colourblindness.  And so you can see, depending on the type of colourblindness a person has, what, what would they perceive when they look at a particular screen?  Okay. So we can test our site and we can make sure, um, that,  that we don't have the wrong sort of contrast across different colours so people wouldn't be able to perceive it.  Okay. So yeah, we don't don't take it out just because % of the population have difficulties with colour.  We just have to make sure that our design, uh, works with the colours that, that we're putting into it.  Um, having things consistent is as important.  I guess a lot of a lot of the heuristics, Nielsen's heuristics and the things that we apply there.  Now we're really looking at consistency. Are they following standards?  Are the standards followed all the way through, um, a particular website or a particular application?  Are they consistently applying the same thing in there. And so that that's really important.  It works at different levels, you know. So um, so for your Meeko is you want consistency of a particular type across different applications and there.  But it doesn't have to be the same across every absolutely the same across every application.  You want consistency within an application.  Um, if you're using the Microsoft Suite, then perhaps you expect more consistency across all of the Microsoft applications.  Um, than than you would, uh, with other applications on, on your system.  So, so we think about consistency at, at different levels depending on what is in there.  And while we strive for consistency, we should also strive for inconsistency and consistency for things which work differently.  And so we want to make sure where something functions in a different way.  It shouldn't look the same as something else. Okay. We should make things look different where they work in a in a different way.  And, uh, as uh, William Buxton says, the most important consistency is consistency with user expectations.  So again, we don't want to have to train people to know what our level of consistency is or what our expectations are.  Much better to work with what their expectations already are.  Uh, in the software that that we have. Um, I'm always using the Auckland University website.  So, you know, I see lots of examples where things are, uh, quite different.  Um, this is, uh, my Auckland uni and, uh, so you can get to my Auckland uni from the front page of, uh, the University of Auckland website.  And you'll see it's very different if you recall what University of Auckland front page looks like.  Um, there's no consistency. And that's it has a very old, uh, logo from the university that five years old.  It's changed probably twice since then. I can say, um, not maintaining any consistency across the platform, um, that we have.  The folks really useful then. And so we should have default information where we can um, but we can always get defaults.  Right. And so make it easy to, to get rid of them.  Uh, this the, the system that I use for doing at the reviews, the conference open call, etc.  Um, system um, put some defaults for uh, some, some of the information about a review.  Um, but if I click on the field with it defaults to get rid of it, I have to take all of the text out.  I have to highlight the whole field and take it out. So it's not not allowing me to easily get rid of the default, which is here.  And you'll see many applications where, um, if you click on a field, the default would disappear.  Make it easy. Uh, we talked about intelligent default.  So you know. Yes, it's fine information about me.  This is intelligent. Um, and this is the sort of default we would want.  Um, when we have that, um, we often use default to mean going back to a previous state.  Um, so we want to, um, reset the values that we have.  Uh, and default is perhaps not a very good word, uh, to mean that, um, so if we're going to reset things, we should say what the reset is.  We should tell people, um, how extensive that reset is going to be.  So I think people, um, often worry about how complex an application looks.  And, and so you try and hide away some of the, the complexity and doing a particular task.  And often that's not useful because if a task is complex, it's complex.  You have to show people all of the steps or get all the information from people about that task.  And so you can't just make something look simple when it's when it's not simple.  You have to be able to manage their expectations of the complexity of, of an application and, and show them the complexity where, where it is.  Um, I said before one of one of the principles, if the user can't find it doesn't exist.  Um, and that's, that's true for many applications in my field.  I, one of the, the computer aided design tools, uh, did a really major upgrade of the centre phase and,  uh, and relaunched the product with, uh, with a new way of accessing the interface.  Um, when they went through, they found they had about  functions which were available to the users.  And so they did card sort and matching to work out which functions go together and which menus they belong to.  They relaunched the application and the feedback they got from users,  like they liked the new interface, but they said, you've given us so much more functionality.  This is amazing. They gave them no more functionality.  Yeah. So they just made visible things that weren't visible previously.  And and people some they were able to discover, uh, functionality that was useful to them inside the system.  So discovery works across a whole range of of aspects.  So especially with, with gestural interfaces. So we don't have a common language for gestures.  And that's proved difficult in developments across lots of different devices that we have.  And so you'll see often there are quite different gestures used for for similar functions depending on what device you're using.  Um, and so showing people what, what that vocabulary of gestures is uh,  is really important so that people can see, uh, what they can do on, on a particular device.  Um, and, and having visual diagrams which, which give an indication of what pinches or um, drag and drop and,  and those sorts of things, uh, gives people an easier way to, um, to be able to find out what those gestures are.  I see there's often a trade off between how fast a user can do something versus the time it takes to develop and.  And I would put to you that that's the user's, uh, ability to be productive, which is the most important part of, of an application.  And so we have the ability to make sure that user can be productive.  Um, and there's a lot of value in that. I, I keep on my point here.  University of Auckland is a really big place. And so if you impose a cost on everyone at the university then then that's really a big cost.  Uh, one of the new tools the university has run out, uh, rolled out as, uh, as a new quarantine system, uh, Microsoft, um,  whatever it's called, uh, the emails come in, junk emails, and you, you have a choice to block them or not block them.  Okay. You say block takes you to a web page?  Very, very slowly. Brings up, um, a form where you can say yes, block and then say done takes , , sometimes s to go through that process.  Yeah. You know, say, okay,  seconds happens once a day, maybe twice a day.  Know. Is that really bad? Say you do the maths.   people, the university,  seconds times  people.  That's that's really close to two days of productivity lost every time.  Everyone in the organisation goes through that process. That happens once a day.  So once a day, the university loses two days productivity because we have this really slow system.  Yeah. And so over a year, you know that's two person years of productivity,  two person years of effort that could go into something which is productive, which has been lost with something that's not productive.  Right. And so why why do we impose this on on users.  And the question has to come back to the development that we have from the approach that we had in the software.  It's inconceivable to think that we couldn't have the software instantaneously throwing up the forms for blocking software.  Why does it take  seconds? No.  No reason apart from poor design or maybe poor hardware selection, that it takes that long to to perform that task for only  people.  So it's a choice that the university is making to prioritise the development time or the hardware costs of  the software of the infrastructure at the university over the time of the people who are having to use it.  And the efficiency would also say, when you're throwing up error messages, those error messages should be useful.  And we've known this since the s, s that.  So this is it still seems inconceivable that so many applications do not give good error messages to the user when something goes wrong.  So telling the user exactly what went wrong not on an error code,  telling them how they recover from that era or the approaches they could take to recover from that era is still,  I would say, a minority of the systems that that are designed.  So in the interfaces, you want people to be able to make their own choices, to explore what's there.  Um, but sometimes you want to guide them to a particular endpoint, um, so that they can be effective.  And getting to the end of, of that. Um, you want people to be able to, um, know where they are in the system.  So, uh, always be confident that they can get back to where they had been.  Get back to the home. Know which site they're they're part of.  So making things reversible is really important. Um, and that still occurs in many places.  I mean, what what year do we teach? Second year software engineering.  Um, yeah, the undo stack. And and what?  You need to push on to an undo stack. Uh, know this is the fundamental basics of of software engineering.  Um, but but still not prevalent across many systems that we have.  Um, this is Microsoft Outlook, and, um, yeah, I have shaky hands and and so sometimes I accidentally click the,  uh, the subject or the, the email address or the priority and move it off the screen and it disappears.  Yeah. And and so I'm left with a screen where I can't see the subject of my emails.  Is there an undo to to do that? Just no undo.  I have to go and find the list of of items which are available to be in the view for for the email,  select the item which I accidentally moved off and put it back into the right place again.  Yeah, so I can make a silly mistake as a user, but I have no way of recovering from it.  And and that means people who are less certain about the use of the software that they are working with.  Uh, we have many paths around the software, uh, icons and interfaces that we have.  So we have different queues, we have colour queues in have sound queues, we can have vibrational queues.  Um, we should be using those parallel sources of information, uh, when we're creating our interfaces.  Um, but standard items should have standard ways of being manipulated and the bottom should be pressed to slide or should slide.  Um, people will understand those conventions.  They met those conventions. We should always make sure that they are working in the in a standard way, um, for the system.  Some of the things that we don't want is as people to to not understand what the system is doing when we're going through.  So, uh, where it's going to take some time to complete a task and we should be providing information to people about about that.  We have a little swirly icon when we know people have to wait, but how quickly do you put that in front of the user?  So how quickly do they understand that the key press button press has been accepted and the system is doing something.  And many, many systems don't do that immediately.  And so you press the button again and you know, that can cause problems with uh, with the software that that is there.  So, uh, reduce the amount of latency that, that people experience.  Make your systems faster, whether it's latency, um, make them know that the user know that, that something is happening and they need to wait for it.  Um, I think that they recommend somewhere around  milliseconds should be the longest that you lay  the data process run before you get the user some feedback that the process is still continuing.  Um, and depending on how long the is going to be, then you take different approaches to giving that information, um, to the user.  Uh, we want things to be learnable. Um, but learnable can be a trade off with usability.  And so looking at, um, how easy something is to learn, uh,  but still ensuring that that the system is going to be usable and we don't just turn test, um,  how how learnable a system is or how memorable a system is,  we still have to test how usable it is to make sure that we're not skewing in favour of one or another.  Um, we know the metaphors are really useful. People understand metaphors.  They understand how to how that impacts on on the software that they're looking at.  Very powerful to, to take that across. Um, but we just.  We can't do that just within the constraints of the physical world.  So, uh, if we have a newspaper and we don't make it exactly like a newspaper.  We have hyperlinks. And I don't have hyperlinks in the, uh, paper.  Newspaper. Yeah. So we take the metaphor. We applied the parts of the metaphor which are useful, but we still augment beyond that metaphor.  Um, for the work that we're doing. And sometimes the metaphor just breaks down.  So, you know, we we don't use it. Um, I think everyone who's heard me in the undergraduate course, I talk about the, you know,  the early car design, uh, where people came from horse and carriage and using reins.  And so some of the first practice use frames as the way of turning left and right and going faster and slower.  Uh, a metaphor for people understood exactly what it did, but it wasn't the right metaphor for guiding a motorised vehicle.  And so you abandon the metaphor and find something else, which is is there?  Uh, people's work is precious. Okay, so in interaction design,  we should be doing the work to make sure that whatever a user has done is safe and is able to be maintained and restored.  And I talked about the review software that I use, uh, which when it times out, just loses all the work.  And so I can write a page or two pages of a really.  And if I don't click the button in the right time, which doesn't tell me what the right time is,  um, then it just discards all of the work that that I've done.  So users shouldn't lose their work. And we have ways of of managing that.  We have ways of, of ensuring our systems are tracking what the user is doing.  Uh, doing saves putting things into cookies. There are many, many ways that we have of ensuring that whatever the user does is actually held in a,  in a particular, um, safe place to be drawn back at a later time.  I want to make sure things, uh, are readable, uh, for people.  So, um, usability. It's not how much information we can get in front of the user, but what's important and how are they able to perceive it.  So having text which has high contrast, uh, large enough font sizes.  So, you know, lots of things are designed by young developers, not by old developers, like like me.  Um, and so you have far better abilities.  Your faster, your eyesight's better, your hearing is better.  Um, but a lot of the population who's going to be using something, uh, uh, getting old and eyesight deteriorates.  I need glasses to be able to see what's on the screen here.  Um, so the testing that you need to do should take into account the whole population and,  and, uh, their ability to perceive the information that is in front of them.  I, we talked a little bit earlier about, um, the simplicity of that.  So, um, uh, being able to, uh, show what's in the system if it's, uh, if it's complex, you need to show the complexity.  Um, but you want to make sure that you're having the least in front of a person that, um, that is possible, um, losing information.  Uh, so, similar to state, making sure that we are keeping the state information where we can keep the state information.  Um, but if we're storing particulars about a user and what the user is doing, we should be encrypting that,  um, and letting the user know what we are holding and and why we are holding it.  Um, and as you will see from so many of the hacks, uh, that have managed to, to penetrate systems in New Zealand and around the world.  Um, that's not always the case with, with information. And so millions and billions of user accounts are being, um, downloaded and they have,  uh, lots of information in there, people's, uh, Social Security numbers in the US.  I think the, uh, the latest one was, uh, over a billion, um,  user accounts that got downloaded, which had, uh, US citizen Social Security numbers in it.  So not stored in, in a, in a state that is easy to get paid.  Um, making sure that the way we navigate this very visible.  Uh, so people can, can understand where they are and what they're doing.  Um, the university website again, you know, we have breadcrumbs everywhere.  Uh, which is is a step up from where they were about five years ago.  Uh, really good thing to have. Um, but what you'll find, and you've probably seen it as you go across the university.  Good sign. As you go from one place to another place.  The breadcrumbs don't always add up through the path that you've progressed through,  but they show you the path of the website that you've landed on, and so suddenly you've lost all the context of where you come from.  You can't go back to the previous place that you were at. Um,  because you've been placed in another part of the website with a different  path from the one that you followed with the breadcrumbs they're giving you.  Um. Okay.  So. Thinking about interaction design,  thinking about lots of different approaches that we can take and some of the considerations that that we should have when  we're looking at interactions and how we can develop in favour of the user rather than favour off the cost of the developer.  And as I say, trying to make the argument that developer time, uh,  while it seems like a cost to an organisation and the cost to the development of the  software is really a much smaller part of the total cost of the use of the software.  And if we think in whole life and we should be thinking about the whole life and use and utility of,  of our software, um, then it's the user and the impact on the user,  the interactions that we're supporting for the user, which are the really important aspect of the software that we're developing.  Questions about their. You say, how is he going to test us on that?  And. I say the test that that we're putting together is focussed around Fitts law.  Um, but some of the questions on Fitts law will be saying, how does Fitts law apply in that particular situation?  And so we might look at some of those interactions and say, and does Fitts law apply in this context?  Or what would Fitzwater say about this particular part of of the interactions that we would have with a system?  Okay. And then this was going to take an hour.  And now it's going to take a quarter of an hour. So just very quickly a light touch on, um, HCI as, as it applies and to a different discipline and,  and what considerations we might need in a, in a different discipline.  And so what I'm going to talk to you about is is construction informatics.  Uh, so this around % of the population in most countries work in the construction industries.  So the people who are building our roads and bridges houses, buildings, your new gym,  which is beautiful, uh, really good people building your new gym there.  Um, I know you'll be called before you can use it, but, um,  the next years are going to be very appreciative of, uh, the money that you put into that new channel.  Um, so the people who are building all of our infrastructure, uh, in the, in the country, uh, thinking about them as,  as a particular audience for software, because we develop software for them to use, but they're very different from us.  And, and so what I want to think about as well, who often is people, um, where do they come from?  What are their understandings? Uh, what knowledge did they have?  And and so how do we think about developing software when,  when we have this population who are working in a very different discipline from, from what we would know?  Um, and the approaches here are very similar to approaches that use and other disciplines.  So if you're developing, um, for, uh, for the hospitals and medical fields, then again, it's similar sort of thing.  Although medical field is much higher trained than the construction industry has the same slight differences.  And then if you're developing for elderly, uh, you know, if you're making apps that might be used in an old age home, uh,  if you're developing for children, again, same sort of approach and considerations, very different category of people.  They're different from us. And we have to think about, uh, what those people are and what their needs are.  And the software that we develop for, for the mass market software that we developed for everyone,  typically not well aligned with the needs of these unique groups.  And so, uh, the approach that we take for mass market, we need to, uh, for, um, for other areas.  Uh, it's a construction. Uh, it's a building.  Amazing buildings. Um, including your gym.  Uh, have I, I I've heard so much about the gym, you know, the the swimming pool,  and they're the, uh, they can raise and lower the the height of the swimming pool,  so it can be a diving pool, and it can be, uh, Olympic racing pool, and it can be for water polo and.  Uh, that's that's incredible. Um. The universe.  Well, I won't say how much money it must have cost to do that.  Um, and then the the basketball courts or the courts.  They have to. Um, it's a glass full with lights underneath to highlight the different courts.  I think there's, there's  or  different layouts they can do in there, depending if you're playing, um, netball,  basketball or whatever else you can can play in there, uh, with different lighting configurations on the, the floor.  Uh, incredible. Um, anyway, uh, so you say construction people build these, these amazing buildings and,  uh, you know, things like, uh, the Burj Khalifa, tallest building in the world.  Um, not not quite a kilometre tall, but, uh, they they're getting close to it now.  Um, large percent of the population.  They are very conservative because they don't actually make very much money.  Uh, so the, um, the profit margins are usually very low in that area.  Um, so, so people are conservative about the software they use and changes.  And in the systems they have, uh, a lot of people are are not highly trained.  So there's a lot of labourers who work on their, uh, in the New Zealand context, we have lots of labourers who come in from overseas.  And so English is not the first language.  And so language skills and comprehension, uh, is not just, uh, low, um, educational training but also low ability and,  and the English language, which we have to think about when we're developing for them.  Um, it's a very dangerous profession. Uh, so, uh, apart from forestry, it's the most dangerous job to be in.  Uh, in New Zealand. It kills and maims many people every year.  Um, and so health and safety and making sure that the systems that we develop, uh, take into consideration the safety aspects of what people do on,  on the site becomes an important consideration, something that you wouldn't consider when you're developing games or, or most other types of software.  But you have to take into account when you're dealing with a profession where, um,  you can be maimed or killed, uh, in the work that you're doing on a day to day basis.  Um, and I say there's a range of different training levels.  Um, so you have people who are trained at the university, the engineers, architects.  Um, people trained in the politics who who will be managing, uh, the projects or the plumbers, electricians and others there.  And then a large number of labourers who are trained in the trades.  Typically on the job. Uh, under the supervision of someone else.  Uh, that's kind of this pyramid that you have, you know, a much smaller number of highly trained people.  Slightly more people who are, um, trained in the politic sector, and then a much larger number of tradespeople who are working there.  Okay, so so I think you've an audience, uh,  the majority of people who are going to be using your applications are people who have had very little training.  They've probably left school as soon as they could leave school to go out and start making money.  Um, and they've the training they have received has really being on the job under the mentorship of someone else.  Uh, the teams are very multi-disciplinary. So you're bringing people from very different understandings.  You have electricians working next to plumbers, working next to labourers, working next to to people with, um, very, very different skills.  Have to manage those. Um, and big projects have a lot of people that, that have to be, uh, managed in that process.  So um, large projects, ten, , people working on the project,  or , people going on and off a site every day, uh, who have to be managed.  The software that they're using has to manage their tasks and their allocation to a space.  And what they're doing, uh, inside that space.  Um, and then to make that even more fun. Uh, has its own language and, and so to understand, uh, architecture and engineering,  uh, you need to understand the symbols which are standard to that domain.  You need to learn a large vocabulary of, of terms with, uh, which represent different aspects of a building.  And that terminology is not consistent across the world.  And so things that we, uh, the names that we have for things in New Zealand are not the same names that you have in the US or the UK,  uh, or in the countries that many of the labourers come from when they come to New Zealand.  So, um, you can see uh, in diagram here, uh, we have uh, symbols for uh, for door, uh, with a line is a door.  And learn fairly quickly to identify doors. It tells you which way the door swings.  Uh, we have, uh, three lines in the case of windows, so we can identify what windows are when we're looking at these things.  So lots and lots and lots of symbols, uh, which represent different concepts.  And there and as developers, when we come into the field, we have to learn that language.  We have to learn those symbols. We have to learn the conventions that people are using to be able to create the software that that we're putting in.  Uh, how different people think about the building is, is also very different.  So this is the same building, but one viewers is what the architect would think of.  One view is what the structural engineer would think of. And another view is what the heating, ventilation, air conditioning engineer would think of.  And so again, as we come into this discipline, we have to understand, uh,  who the different professions are and what their needs are in terms of how we visualise and present information to them.  And as you can see, that's going to change dramatically depending on who it is that that we're working with.  So it's a large field. % of the population internationally working in this field.  Um, many pieces of software developed for for people working in this field.  Uh, but HCI considerations really have been, uh, very poorly considered.  And a lot of the software that has there and, and so that's, um, you know, an issue that, that we try and resolve and,  and think about in the work that we do here and, and at other universities around the world.  So I'll show you just a couple of projects where, where we try and take the processes that they have,  and we think about how computers can, can support and enhance the processes.  Uh, so, uh, this is a design review process and, uh, you might recognise it to some of the design review that you might have done in HCI.  Um, so when an architect comes up with a particular design for a building, um, then they'll go into a review and critique session.  And so what you see here is an architect presenting their design to a range of other experts.  And those experts look at the design and they look at it from their perspectives and they critique,  uh, you know, whether the it's the structural system that's going to work for that, um,  what the flows are going to be like for the people,  all of the different aspects look at the design and critique the design so that we can iterate on the design and make it,  um, a better, better outcome for it. So you can see this process, um, very, very human based.  People have to be in situ. They have to be in the room.  They have to get an explanation from the architect as to what their intention was.  Um, and has to happen, um, synchronously, every everyone has to be there at the same time for it.  Uh, so this was a soft, impactful project, um, several years ago, uh, who looked at, uh,  trying to see what we might do with a game environment to be able to do the same sort of thing.  Um, so here the critique happens within a game environment.  Um, we have the ability to, to mark up inside the game environment, uh, where, where we see an issue inside there.  We have a, um, uh, posts that that people were allowed to, uh, put on information about, uh, the,  the design, uh, we capture the locations that that different issues, uh, exist inside the design.  So you can always go and have a look at issues, and you can have a look at the conversation that happens around.  It means that things don't have to be synchronous. You don't have to have everyone in the room.  They can be scattered across the world. They can be working at different times.  Um, but they can still come back to the conversation and into the conversation and make suggestions about the design, uh, which is there.  So improves the communication, improves the collaboration.  Um. But doesn't really improve the, uh, the, the conversation overall.  You know, that that what what they found when the, uh, putting the software together is that having everyone in the room discussing the design,  um, gave as many outcomes as having, uh, this asynchronous view where people were able to go and, uh, and, and work on it in their own time.  Um, so, so still some things to, to do on it.  And, uh, this is another, another project I which looked at, um, doing the same sort of thing, but uh, different form of navigation.  So here, here they were looking at, uh, how you got around the design, what sort of interface might work on a, on a large interactive device?  Uh, if you are trying to navigate and show someone a design that that you're working on.  Um, because construction is very dangerous.  Dirty. Uh, there's a lot of interest in gesture based interfaces.  So, uh, the thought being with a gesture based interface, it doesn't matter if you're wearing gloves.  It doesn't matter if you're covered in mud or concrete or whatever that you're doing.  Uh, the system's able to recognise your hands or what you're trying to gesture.  Um, then you could drive a computer system without having to have a a keyboard, mouse, touchpad, any of any of those, um, sort of, um, systems.  So a whole lot of work happening in this area trying to say, well, um,  can we introduce gestures into a construction site as a way of being able to communicate and collaborate and gain information,  navigate the information that that people need inside that environment?  Yeah. And so I can imagine if you're up on the steelwork, uh, doing some welding up on the steel work or bolting things in on the steel work there,  then you don't want to have a tablet that you have to access, um, or a keyboard or something else to access.  Um, being able to overlay information onto the goggles that they're wearing would be a really nice way of presenting information.  Uh, and having gestures as a way of navigating that. What would work?  Um, at the moment, uh, people control that by, by just having playthroughs, which can take you one path through the information that that you have.  And the thought with gestures is that it would be, um, a way of, of being able to give people more control over, over what, what they saw, you know.  So there's a couple of projects here. I'll just talk for a minute about one of them.  Um, this one we were looking at, um, whole body gestures.  Uh, so, um, looking at, uh, what could be recognised.  So this was, uh, with a Kinect. Um, so recognising body posture and and what sort of gestures people would have.  Uh, for that, I'd say there's no common understanding of gestures for particular movements, um, or particular functions.  And so we're always inventing a gesture set.  And so a lot of the work in this area is trying to find what are the appropriate gestures that people would use to perform a particular function for,  for construction professionals. And uh, and these ones, you can see a range of gestures that, that were developed that, um,  were felt to be intuitive, uh, learnable, memorable for, for people who are going to be using the system.  Um. Yeah.  You always make tough decisions when you develop a system. Um, so the well, the first, um, decision that that made and this was saying, well,  would we have a gesture where if you stepped forward to recognise the state as moving forward,  uh, and, and the decision was, you know, if, if my state forward by more than a certain number of centimetres,  then we'd recognise that as, as a movement.  Uh, and of course, some people are short and some people are tall, and the distance that people step forward is, is quite different.  Um, so, uh, just having a fixed distance to recognise a step didn't work and you had to adapt it to the height of the person who was who was in there.  Uh, so that's a good HCI project.  Um, they looked at, uh, the different gestures they had.  Ease of use and accuracy, um, of the gestures across a set of, uh, participants.  Um, looking at, uh, how memorable uh, the gesture was, um, looking at levels of fatigue on the gestures.  Uh, so again, if people are using this sort of approach, then, um, you know,  then how quickly are they going to get fatigue, which gestures, uh, are going to cause fatigue?  
